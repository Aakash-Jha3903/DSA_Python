[
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "dijkstra",
        "kind": 2,
        "importPath": "Graphs.Shortest_path_algorithms.Dijkstra_algorithm",
        "description": "Graphs.Shortest_path_algorithms.Dijkstra_algorithm",
        "peekOfCode": "def dijkstra(graph, start):\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    visited = set()\n    while len(visited) < len(graph):\n        min_node = None\n        min_distance = float('infinity')\n        for node in graph:\n            if node not in visited and distances[node] < min_distance:\n                min_node = node",
        "detail": "Graphs.Shortest_path_algorithms.Dijkstra_algorithm",
        "documentation": {}
    },
    {
        "label": "graph",
        "kind": 5,
        "importPath": "Graphs.Shortest_path_algorithms.Dijkstra_algorithm",
        "description": "Graphs.Shortest_path_algorithms.Dijkstra_algorithm",
        "peekOfCode": "graph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\nstart_node = 'A'\ndistances = dijkstra(graph, start_node)\nprint(f\"Shortest distances from {start_node}: {distances}\")",
        "detail": "Graphs.Shortest_path_algorithms.Dijkstra_algorithm",
        "documentation": {}
    },
    {
        "label": "start_node",
        "kind": 5,
        "importPath": "Graphs.Shortest_path_algorithms.Dijkstra_algorithm",
        "description": "Graphs.Shortest_path_algorithms.Dijkstra_algorithm",
        "peekOfCode": "start_node = 'A'\ndistances = dijkstra(graph, start_node)\nprint(f\"Shortest distances from {start_node}: {distances}\")",
        "detail": "Graphs.Shortest_path_algorithms.Dijkstra_algorithm",
        "documentation": {}
    },
    {
        "label": "distances",
        "kind": 5,
        "importPath": "Graphs.Shortest_path_algorithms.Dijkstra_algorithm",
        "description": "Graphs.Shortest_path_algorithms.Dijkstra_algorithm",
        "peekOfCode": "distances = dijkstra(graph, start_node)\nprint(f\"Shortest distances from {start_node}: {distances}\")",
        "detail": "Graphs.Shortest_path_algorithms.Dijkstra_algorithm",
        "documentation": {}
    },
    {
        "label": "floyd_warshall",
        "kind": 2,
        "importPath": "Graphs.Floyd_warshall_Algorithm",
        "description": "Graphs.Floyd_warshall_Algorithm",
        "peekOfCode": "def floyd_warshall(graph, n):\n    dist = [[float('inf')] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            dist[i][j] = graph[i][j]\n    for i in range(n):\n        dist[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):",
        "detail": "Graphs.Floyd_warshall_Algorithm",
        "documentation": {}
    },
    {
        "label": "warshall",
        "kind": 2,
        "importPath": "Graphs.Warshall_Algorithm",
        "description": "Graphs.Warshall_Algorithm",
        "peekOfCode": "def warshall(graph, n):\n    reach = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            reach[i][j] = graph[i][j]\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                reach[i][j] = reach[i][j] or (reach[i][k] and reach[k][j])\n    print(\"\\nTransitive Closure:\")",
        "detail": "Graphs.Warshall_Algorithm",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "Linked_List.circular_LL",
        "description": "Linked_List.circular_LL",
        "peekOfCode": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\nclass CircularLinkedList:\n    def __init__(self):\n        self.head = None\n        self.length = 0\n    def display(self):\n        if self.head:",
        "detail": "Linked_List.circular_LL",
        "documentation": {}
    },
    {
        "label": "CircularLinkedList",
        "kind": 6,
        "importPath": "Linked_List.circular_LL",
        "description": "Linked_List.circular_LL",
        "peekOfCode": "class CircularLinkedList:\n    def __init__(self):\n        self.head = None\n        self.length = 0\n    def display(self):\n        if self.head:\n            print(\"This is your Circular Linked List:\")\n            n = self.length\n            temp = self.head\n            for _ in range(n):",
        "detail": "Linked_List.circular_LL",
        "documentation": {}
    },
    {
        "label": "menu",
        "kind": 2,
        "importPath": "Linked_List.circular_LL",
        "description": "Linked_List.circular_LL",
        "peekOfCode": "def menu():\n    linked_list = CircularLinkedList()\n    while True:\n        print(\"\\n0. Create a Circular linked list with N nodes\")\n        print(\"1. Insert at start\")\n        print(\"2. Insert at end\")\n        print(\"3. Delete first node\")\n        print(\"4. Delete last node\")\n        print(\"5. Insert at position\")\n        print(\"6. Delete at position\")",
        "detail": "Linked_List.circular_LL",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "Linked_List.Doubly_Linked_List",
        "description": "Linked_List.Doubly_Linked_List",
        "peekOfCode": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.prev = None\n        self.next = None\nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n        # self.tail = None\n        self.length = 0",
        "detail": "Linked_List.Doubly_Linked_List",
        "documentation": {}
    },
    {
        "label": "DoublyLinkedList",
        "kind": 6,
        "importPath": "Linked_List.Doubly_Linked_List",
        "description": "Linked_List.Doubly_Linked_List",
        "peekOfCode": "class DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n        # self.tail = None\n        self.length = 0\n    def display(self):\n        if self.head:\n            print(\"This is your Doubly Linked List:\")\n            n = self.length\n            temp = self.head",
        "detail": "Linked_List.Doubly_Linked_List",
        "documentation": {}
    },
    {
        "label": "menu",
        "kind": 2,
        "importPath": "Linked_List.Doubly_Linked_List",
        "description": "Linked_List.Doubly_Linked_List",
        "peekOfCode": "def menu():\n    linked_list = DoublyLinkedList()\n    while True:\n        print(\"\\n0. Create a Doubly Linked List with N nodes\")\n        print(\"1. Insert at start\")\n        print(\"2. Insert at end\")\n        print(\"3. Delete first node\")\n        print(\"4. Delete last node\")\n        print(\"5. Insert at position\")\n        print(\"6. Delete at position\")",
        "detail": "Linked_List.Doubly_Linked_List",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "Linked_List.node",
        "description": "Linked_List.node",
        "peekOfCode": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\na = Node(1)\nb = Node(2)\nc = Node(3)\nd = Node(4)\na.next = b\nb.next = c",
        "detail": "Linked_List.node",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "Linked_List.node",
        "description": "Linked_List.node",
        "peekOfCode": "a = Node(1)\nb = Node(2)\nc = Node(3)\nd = Node(4)\na.next = b\nb.next = c\nc.next = d\n# display the data of linked list  \ni = a\n# while (i != None):   # parenthesis is not compulsary ",
        "detail": "Linked_List.node",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "Linked_List.node",
        "description": "Linked_List.node",
        "peekOfCode": "b = Node(2)\nc = Node(3)\nd = Node(4)\na.next = b\nb.next = c\nc.next = d\n# display the data of linked list  \ni = a\n# while (i != None):   # parenthesis is not compulsary \n# while i != None:     # \"!=\" can be replace by \"is not\"",
        "detail": "Linked_List.node",
        "documentation": {}
    },
    {
        "label": "c",
        "kind": 5,
        "importPath": "Linked_List.node",
        "description": "Linked_List.node",
        "peekOfCode": "c = Node(3)\nd = Node(4)\na.next = b\nb.next = c\nc.next = d\n# display the data of linked list  \ni = a\n# while (i != None):   # parenthesis is not compulsary \n# while i != None:     # \"!=\" can be replace by \"is not\"\nwhile i is not None:",
        "detail": "Linked_List.node",
        "documentation": {}
    },
    {
        "label": "d",
        "kind": 5,
        "importPath": "Linked_List.node",
        "description": "Linked_List.node",
        "peekOfCode": "d = Node(4)\na.next = b\nb.next = c\nc.next = d\n# display the data of linked list  \ni = a\n# while (i != None):   # parenthesis is not compulsary \n# while i != None:     # \"!=\" can be replace by \"is not\"\nwhile i is not None:\n    print(i.data)",
        "detail": "Linked_List.node",
        "documentation": {}
    },
    {
        "label": "a.next",
        "kind": 5,
        "importPath": "Linked_List.node",
        "description": "Linked_List.node",
        "peekOfCode": "a.next = b\nb.next = c\nc.next = d\n# display the data of linked list  \ni = a\n# while (i != None):   # parenthesis is not compulsary \n# while i != None:     # \"!=\" can be replace by \"is not\"\nwhile i is not None:\n    print(i.data)\n    i = i.next",
        "detail": "Linked_List.node",
        "documentation": {}
    },
    {
        "label": "b.next",
        "kind": 5,
        "importPath": "Linked_List.node",
        "description": "Linked_List.node",
        "peekOfCode": "b.next = c\nc.next = d\n# display the data of linked list  \ni = a\n# while (i != None):   # parenthesis is not compulsary \n# while i != None:     # \"!=\" can be replace by \"is not\"\nwhile i is not None:\n    print(i.data)\n    i = i.next\n# print(\"The value of a is \")",
        "detail": "Linked_List.node",
        "documentation": {}
    },
    {
        "label": "c.next",
        "kind": 5,
        "importPath": "Linked_List.node",
        "description": "Linked_List.node",
        "peekOfCode": "c.next = d\n# display the data of linked list  \ni = a\n# while (i != None):   # parenthesis is not compulsary \n# while i != None:     # \"!=\" can be replace by \"is not\"\nwhile i is not None:\n    print(i.data)\n    i = i.next\n# print(\"The value of a is \")\n# print(a.data)",
        "detail": "Linked_List.node",
        "documentation": {}
    },
    {
        "label": "i",
        "kind": 5,
        "importPath": "Linked_List.node",
        "description": "Linked_List.node",
        "peekOfCode": "i = a\n# while (i != None):   # parenthesis is not compulsary \n# while i != None:     # \"!=\" can be replace by \"is not\"\nwhile i is not None:\n    print(i.data)\n    i = i.next\n# print(\"The value of a is \")\n# print(a.data)\n# print(\"The address(next) of a is \")\n# print(a.next)",
        "detail": "Linked_List.node",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "Linked_List.Singly_LL",
        "description": "Linked_List.Singly_LL",
        "peekOfCode": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\nclass SinglyLinkedList:\n    def __init__(self):\n        self.head = None\n        self.length = 0\n    def insert_at_start(self, data):\n        new_node = Node(data)",
        "detail": "Linked_List.Singly_LL",
        "documentation": {}
    },
    {
        "label": "SinglyLinkedList",
        "kind": 6,
        "importPath": "Linked_List.Singly_LL",
        "description": "Linked_List.Singly_LL",
        "peekOfCode": "class SinglyLinkedList:\n    def __init__(self):\n        self.head = None\n        self.length = 0\n    def insert_at_start(self, data):\n        new_node = Node(data)\n        new_node.next = self.head\n        self.head = new_node\n        self.length += 1\n    def insert_at_end(self, data):",
        "detail": "Linked_List.Singly_LL",
        "documentation": {}
    },
    {
        "label": "menu",
        "kind": 2,
        "importPath": "Linked_List.Singly_LL",
        "description": "Linked_List.Singly_LL",
        "peekOfCode": "def menu():\n    linked_list = SinglyLinkedList()\n    while True:\n        print(\"\\n1. Insert at start\")\n        print(\"2. Insert at end\")\n        print(\"3. Delete first node\")\n        print(\"4. Delete last node\")\n        print(\"5. Insert at position\")\n        print(\"6. Delete at position\")\n        print(\"7. Display Linked-List\")",
        "detail": "Linked_List.Singly_LL",
        "documentation": {}
    },
    {
        "label": "BankersAlgorithm",
        "kind": 6,
        "importPath": "Operating_System_Algorithms.Bankers_Algorithm",
        "description": "Operating_System_Algorithms.Bankers_Algorithm",
        "peekOfCode": "class BankersAlgorithm:\n    def __init__(self, available, max_demand, allocation):\n        self.available = np.array(available)\n        self.max_demand = np.array(max_demand)\n        self.allocation = np.array(allocation)\n        self.num_processes = self.max_demand.shape[0]\n        self.num_resources = self.available.shape[0]\n        self.need = self.max_demand - self.allocation\n    def is_safe_state(self):\n        work = np.copy(self.available)",
        "detail": "Operating_System_Algorithms.Bankers_Algorithm",
        "documentation": {}
    },
    {
        "label": "available_resources",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.Bankers_Algorithm",
        "description": "Operating_System_Algorithms.Bankers_Algorithm",
        "peekOfCode": "available_resources = [3, 3, 2]\nmax_demand = [\n    [7, 5, 3],\n    [3, 2, 2],\n    [9, 0, 2],\n    [2, 2, 2],\n    [4, 3, 3]\n]\nallocation = [\n    [0, 1, 0],",
        "detail": "Operating_System_Algorithms.Bankers_Algorithm",
        "documentation": {}
    },
    {
        "label": "max_demand",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.Bankers_Algorithm",
        "description": "Operating_System_Algorithms.Bankers_Algorithm",
        "peekOfCode": "max_demand = [\n    [7, 5, 3],\n    [3, 2, 2],\n    [9, 0, 2],\n    [2, 2, 2],\n    [4, 3, 3]\n]\nallocation = [\n    [0, 1, 0],\n    [2, 0, 0],",
        "detail": "Operating_System_Algorithms.Bankers_Algorithm",
        "documentation": {}
    },
    {
        "label": "allocation",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.Bankers_Algorithm",
        "description": "Operating_System_Algorithms.Bankers_Algorithm",
        "peekOfCode": "allocation = [\n    [0, 1, 0],\n    [2, 0, 0],\n    [3, 0, 2],\n    [2, 1, 1],\n    [0, 0, 2]\n]\nbankers = BankersAlgorithm(available_resources, max_demand, allocation)\nprint(\"Initial State:\")\nprint(f\"Available Resources: {bankers.available}\")",
        "detail": "Operating_System_Algorithms.Bankers_Algorithm",
        "documentation": {}
    },
    {
        "label": "bankers",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.Bankers_Algorithm",
        "description": "Operating_System_Algorithms.Bankers_Algorithm",
        "peekOfCode": "bankers = BankersAlgorithm(available_resources, max_demand, allocation)\nprint(\"Initial State:\")\nprint(f\"Available Resources: {bankers.available}\")\nprint(f\"Maximum Demand: \\n{bankers.max_demand}\")\nprint(f\"Allocation: \\n{bankers.allocation}\")\nprint(f\"Need: \\n{bankers.need}\")\nprocess_num = 1\nrequest = [1, 0, 2]\nprint(f\"\\nProcess {process_num} requesting resources {request}\")\nbankers.request_resources(process_num, request)",
        "detail": "Operating_System_Algorithms.Bankers_Algorithm",
        "documentation": {}
    },
    {
        "label": "process_num",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.Bankers_Algorithm",
        "description": "Operating_System_Algorithms.Bankers_Algorithm",
        "peekOfCode": "process_num = 1\nrequest = [1, 0, 2]\nprint(f\"\\nProcess {process_num} requesting resources {request}\")\nbankers.request_resources(process_num, request)\nsafe, safe_sequence = bankers.is_safe_state()\nprint(f\"\\nSystem is in a {'safe' if safe else 'unsafe'} state.\")\nif safe:\n    print(f\"Safe sequence: {safe_sequence}\")",
        "detail": "Operating_System_Algorithms.Bankers_Algorithm",
        "documentation": {}
    },
    {
        "label": "request",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.Bankers_Algorithm",
        "description": "Operating_System_Algorithms.Bankers_Algorithm",
        "peekOfCode": "request = [1, 0, 2]\nprint(f\"\\nProcess {process_num} requesting resources {request}\")\nbankers.request_resources(process_num, request)\nsafe, safe_sequence = bankers.is_safe_state()\nprint(f\"\\nSystem is in a {'safe' if safe else 'unsafe'} state.\")\nif safe:\n    print(f\"Safe sequence: {safe_sequence}\")",
        "detail": "Operating_System_Algorithms.Bankers_Algorithm",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Operating_System_Algorithms.FCFS",
        "description": "Operating_System_Algorithms.FCFS",
        "peekOfCode": "def main():\n    bt = []\n    wt = []\n    tat = []\n    wtavg = 0\n    tatavg = 0\n    n = int(input(\"\\nEnter the number of processes -- \"))\n    # Input burst times for each process\n    for i in range(n):\n        bt.append(int(input(f\"Enter Burst Time for Process {i} -- \")))",
        "detail": "Operating_System_Algorithms.FCFS",
        "documentation": {}
    },
    {
        "label": "producer",
        "kind": 2,
        "importPath": "Operating_System_Algorithms.inter_process_comm",
        "description": "Operating_System_Algorithms.inter_process_comm",
        "peekOfCode": "def producer():\n    global buffer, mutex, full, empty\n    item_count = 0\n    while True:\n        if mutex == 1 and empty != 0:\n            mutex -= 1\n            item = random.randint(1, 100)\n            buffer.append(item)\n            item_count += 1\n            full += 1",
        "detail": "Operating_System_Algorithms.inter_process_comm",
        "documentation": {}
    },
    {
        "label": "consumer",
        "kind": 2,
        "importPath": "Operating_System_Algorithms.inter_process_comm",
        "description": "Operating_System_Algorithms.inter_process_comm",
        "peekOfCode": "def consumer():\n    global buffer, mutex, full, empty\n    item_count = 0\n    while True:\n        if mutex == 1 and full != 0:\n            mutex -= 1\n            item = buffer.pop(0)\n            item_count += 1\n            full -= 1\n            empty += 1",
        "detail": "Operating_System_Algorithms.inter_process_comm",
        "documentation": {}
    },
    {
        "label": "buffer",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.inter_process_comm",
        "description": "Operating_System_Algorithms.inter_process_comm",
        "peekOfCode": "buffer = []\nbuffer_size = 10\n# Initialize the semaphore variables\nmutex = 1\nfull = 0\nempty = buffer_size\ndef producer():\n    global buffer, mutex, full, empty\n    item_count = 0\n    while True:",
        "detail": "Operating_System_Algorithms.inter_process_comm",
        "documentation": {}
    },
    {
        "label": "buffer_size",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.inter_process_comm",
        "description": "Operating_System_Algorithms.inter_process_comm",
        "peekOfCode": "buffer_size = 10\n# Initialize the semaphore variables\nmutex = 1\nfull = 0\nempty = buffer_size\ndef producer():\n    global buffer, mutex, full, empty\n    item_count = 0\n    while True:\n        if mutex == 1 and empty != 0:",
        "detail": "Operating_System_Algorithms.inter_process_comm",
        "documentation": {}
    },
    {
        "label": "mutex",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.inter_process_comm",
        "description": "Operating_System_Algorithms.inter_process_comm",
        "peekOfCode": "mutex = 1\nfull = 0\nempty = buffer_size\ndef producer():\n    global buffer, mutex, full, empty\n    item_count = 0\n    while True:\n        if mutex == 1 and empty != 0:\n            mutex -= 1\n            item = random.randint(1, 100)",
        "detail": "Operating_System_Algorithms.inter_process_comm",
        "documentation": {}
    },
    {
        "label": "full",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.inter_process_comm",
        "description": "Operating_System_Algorithms.inter_process_comm",
        "peekOfCode": "full = 0\nempty = buffer_size\ndef producer():\n    global buffer, mutex, full, empty\n    item_count = 0\n    while True:\n        if mutex == 1 and empty != 0:\n            mutex -= 1\n            item = random.randint(1, 100)\n            buffer.append(item)",
        "detail": "Operating_System_Algorithms.inter_process_comm",
        "documentation": {}
    },
    {
        "label": "empty",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.inter_process_comm",
        "description": "Operating_System_Algorithms.inter_process_comm",
        "peekOfCode": "empty = buffer_size\ndef producer():\n    global buffer, mutex, full, empty\n    item_count = 0\n    while True:\n        if mutex == 1 and empty != 0:\n            mutex -= 1\n            item = random.randint(1, 100)\n            buffer.append(item)\n            item_count += 1",
        "detail": "Operating_System_Algorithms.inter_process_comm",
        "documentation": {}
    },
    {
        "label": "Process",
        "kind": 6,
        "importPath": "Operating_System_Algorithms.priority_algorithm",
        "description": "Operating_System_Algorithms.priority_algorithm",
        "peekOfCode": "class Process:\n    def __init__(self, pid, burst_time, priority):\n        self.pid = pid\n        self.burst_time = burst_time\n        self.priority = priority\n        self.waiting_time = 0\n        self.turnaround_time = 0\ndef priority_scheduling(processes):\n    processes.sort(key=lambda x: x.priority)\n    processes[0].waiting_time = 0",
        "detail": "Operating_System_Algorithms.priority_algorithm",
        "documentation": {}
    },
    {
        "label": "priority_scheduling",
        "kind": 2,
        "importPath": "Operating_System_Algorithms.priority_algorithm",
        "description": "Operating_System_Algorithms.priority_algorithm",
        "peekOfCode": "def priority_scheduling(processes):\n    processes.sort(key=lambda x: x.priority)\n    processes[0].waiting_time = 0\n    processes[0].turnaround_time = processes[0].burst_time\n    for i in range(1, len(processes)):\n        processes[i].waiting_time = processes[i - 1].waiting_time + processes[i - 1].burst_time\n        processes[i].turnaround_time = processes[i].waiting_time + processes[i].burst_time\ndef main():\n    n = int(input(\"Enter the number of processes: \"))\n    processes = []",
        "detail": "Operating_System_Algorithms.priority_algorithm",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Operating_System_Algorithms.priority_algorithm",
        "description": "Operating_System_Algorithms.priority_algorithm",
        "peekOfCode": "def main():\n    n = int(input(\"Enter the number of processes: \"))\n    processes = []\n    for i in range(n):\n        burst_time = int(input(f\"Enter burst time for process {i + 1}: \"))\n        priority = int(input(f\"Enter priority for process {i + 1}: \"))\n        processes.append(Process(i + 1, burst_time, priority))\n    priority_scheduling(processes)\n    total_waiting_time = 0\n    total_turnaround_time = 0",
        "detail": "Operating_System_Algorithms.priority_algorithm",
        "documentation": {}
    },
    {
        "label": "ite",
        "kind": 6,
        "importPath": "Operating_System_Algorithms.priority_Queue",
        "description": "Operating_System_Algorithms.priority_Queue",
        "peekOfCode": "class item :\n\tvalue = 0\n\tpriority = 0\nclass GFG :\n\t# Store the element of a priority queue\n\tpr = [None] * (100000)\n\t# Pointer to the last index\n\tsize = -1\n\t# Function to insert a new element\n\t# into priority queue",
        "detail": "Operating_System_Algorithms.priority_Queue",
        "documentation": {}
    },
    {
        "label": "GF",
        "kind": 6,
        "importPath": "Operating_System_Algorithms.priority_Queue",
        "description": "Operating_System_Algorithms.priority_Queue",
        "peekOfCode": "class GFG :\n\t# Store the element of a priority queue\n\tpr = [None] * (100000)\n\t# Pointer to the last index\n\tsize = -1\n\t# Function to insert a new element\n\t# into priority queue\n\t@staticmethod\n\tdef enqueue( value, priority) :\n\t\t# Increase the size",
        "detail": "Operating_System_Algorithms.priority_Queue",
        "documentation": {}
    },
    {
        "label": "\tvalue",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.priority_Queue",
        "description": "Operating_System_Algorithms.priority_Queue",
        "peekOfCode": "\tvalue = 0\n\tpriority = 0\nclass GFG :\n\t# Store the element of a priority queue\n\tpr = [None] * (100000)\n\t# Pointer to the last index\n\tsize = -1\n\t# Function to insert a new element\n\t# into priority queue\n\t@staticmethod",
        "detail": "Operating_System_Algorithms.priority_Queue",
        "documentation": {}
    },
    {
        "label": "\tpriority",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.priority_Queue",
        "description": "Operating_System_Algorithms.priority_Queue",
        "peekOfCode": "\tpriority = 0\nclass GFG :\n\t# Store the element of a priority queue\n\tpr = [None] * (100000)\n\t# Pointer to the last index\n\tsize = -1\n\t# Function to insert a new element\n\t# into priority queue\n\t@staticmethod\n\tdef enqueue( value, priority) :",
        "detail": "Operating_System_Algorithms.priority_Queue",
        "documentation": {}
    },
    {
        "label": "\tpr",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.priority_Queue",
        "description": "Operating_System_Algorithms.priority_Queue",
        "peekOfCode": "\tpr = [None] * (100000)\n\t# Pointer to the last index\n\tsize = -1\n\t# Function to insert a new element\n\t# into priority queue\n\t@staticmethod\n\tdef enqueue( value, priority) :\n\t\t# Increase the size\n\t\tGFG.size += 1\n\t\t# Insert the element",
        "detail": "Operating_System_Algorithms.priority_Queue",
        "documentation": {}
    },
    {
        "label": "\tsize",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.priority_Queue",
        "description": "Operating_System_Algorithms.priority_Queue",
        "peekOfCode": "\tsize = -1\n\t# Function to insert a new element\n\t# into priority queue\n\t@staticmethod\n\tdef enqueue( value, priority) :\n\t\t# Increase the size\n\t\tGFG.size += 1\n\t\t# Insert the element\n\t\tGFG.pr[GFG.size] = item()\n\t\tGFG.pr[GFG.size].value = value",
        "detail": "Operating_System_Algorithms.priority_Queue",
        "documentation": {}
    },
    {
        "label": "\t\tGFG.pr[GFG.size]",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.priority_Queue",
        "description": "Operating_System_Algorithms.priority_Queue",
        "peekOfCode": "\t\tGFG.pr[GFG.size] = item()\n\t\tGFG.pr[GFG.size].value = value\n\t\tGFG.pr[GFG.size].priority = priority\n\t# Function to check the top element\n\t@staticmethod\n\tdef peek() :\n\t\thighestPriority = -sys.maxsize\n\t\tind = -1\n\t\t# Check for the element with\n\t\t# highest priority",
        "detail": "Operating_System_Algorithms.priority_Queue",
        "documentation": {}
    },
    {
        "label": "\t\tGFG.pr[GFG.size].value",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.priority_Queue",
        "description": "Operating_System_Algorithms.priority_Queue",
        "peekOfCode": "\t\tGFG.pr[GFG.size].value = value\n\t\tGFG.pr[GFG.size].priority = priority\n\t# Function to check the top element\n\t@staticmethod\n\tdef peek() :\n\t\thighestPriority = -sys.maxsize\n\t\tind = -1\n\t\t# Check for the element with\n\t\t# highest priority\n\t\ti = 0",
        "detail": "Operating_System_Algorithms.priority_Queue",
        "documentation": {}
    },
    {
        "label": "\t\tGFG.pr[GFG.size].priority",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.priority_Queue",
        "description": "Operating_System_Algorithms.priority_Queue",
        "peekOfCode": "\t\tGFG.pr[GFG.size].priority = priority\n\t# Function to check the top element\n\t@staticmethod\n\tdef peek() :\n\t\thighestPriority = -sys.maxsize\n\t\tind = -1\n\t\t# Check for the element with\n\t\t# highest priority\n\t\ti = 0\n\t\twhile (i <= GFG.size) :",
        "detail": "Operating_System_Algorithms.priority_Queue",
        "documentation": {}
    },
    {
        "label": "\t\thighestPriority",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.priority_Queue",
        "description": "Operating_System_Algorithms.priority_Queue",
        "peekOfCode": "\t\thighestPriority = -sys.maxsize\n\t\tind = -1\n\t\t# Check for the element with\n\t\t# highest priority\n\t\ti = 0\n\t\twhile (i <= GFG.size) :\n\t\t\t# If priority is same choose\n\t\t\t# the element with the\n\t\t\t# highest value\n\t\t\tif (highestPriority == GFG.pr[i].priority and ind > -1 and GFG.pr[ind].value < GFG.pr[i].value) :",
        "detail": "Operating_System_Algorithms.priority_Queue",
        "documentation": {}
    },
    {
        "label": "\t\tind",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.priority_Queue",
        "description": "Operating_System_Algorithms.priority_Queue",
        "peekOfCode": "\t\tind = -1\n\t\t# Check for the element with\n\t\t# highest priority\n\t\ti = 0\n\t\twhile (i <= GFG.size) :\n\t\t\t# If priority is same choose\n\t\t\t# the element with the\n\t\t\t# highest value\n\t\t\tif (highestPriority == GFG.pr[i].priority and ind > -1 and GFG.pr[ind].value < GFG.pr[i].value) :\n\t\t\t\thighestPriority = GFG.pr[i].priority",
        "detail": "Operating_System_Algorithms.priority_Queue",
        "documentation": {}
    },
    {
        "label": "\t\ti",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.priority_Queue",
        "description": "Operating_System_Algorithms.priority_Queue",
        "peekOfCode": "\t\ti = 0\n\t\twhile (i <= GFG.size) :\n\t\t\t# If priority is same choose\n\t\t\t# the element with the\n\t\t\t# highest value\n\t\t\tif (highestPriority == GFG.pr[i].priority and ind > -1 and GFG.pr[ind].value < GFG.pr[i].value) :\n\t\t\t\thighestPriority = GFG.pr[i].priority\n\t\t\t\tind = i\n\t\t\telif(highestPriority < GFG.pr[i].priority) :\n\t\t\t\thighestPriority = GFG.pr[i].priority",
        "detail": "Operating_System_Algorithms.priority_Queue",
        "documentation": {}
    },
    {
        "label": "\t\t\t\thighestPriority",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.priority_Queue",
        "description": "Operating_System_Algorithms.priority_Queue",
        "peekOfCode": "\t\t\t\thighestPriority = GFG.pr[i].priority\n\t\t\t\tind = i\n\t\t\telif(highestPriority < GFG.pr[i].priority) :\n\t\t\t\thighestPriority = GFG.pr[i].priority\n\t\t\t\tind = i\n\t\t\ti += 1\n\t\t# Return position of the element\n\t\treturn ind\n\t# Function to remove the element with\n\t# the highest priority",
        "detail": "Operating_System_Algorithms.priority_Queue",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tind",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.priority_Queue",
        "description": "Operating_System_Algorithms.priority_Queue",
        "peekOfCode": "\t\t\t\tind = i\n\t\t\telif(highestPriority < GFG.pr[i].priority) :\n\t\t\t\thighestPriority = GFG.pr[i].priority\n\t\t\t\tind = i\n\t\t\ti += 1\n\t\t# Return position of the element\n\t\treturn ind\n\t# Function to remove the element with\n\t# the highest priority\n\t@staticmethod",
        "detail": "Operating_System_Algorithms.priority_Queue",
        "documentation": {}
    },
    {
        "label": "\t\t\t\thighestPriority",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.priority_Queue",
        "description": "Operating_System_Algorithms.priority_Queue",
        "peekOfCode": "\t\t\t\thighestPriority = GFG.pr[i].priority\n\t\t\t\tind = i\n\t\t\ti += 1\n\t\t# Return position of the element\n\t\treturn ind\n\t# Function to remove the element with\n\t# the highest priority\n\t@staticmethod\n\tdef dequeue() :\n\t\t# Find the position of the element",
        "detail": "Operating_System_Algorithms.priority_Queue",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tind",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.priority_Queue",
        "description": "Operating_System_Algorithms.priority_Queue",
        "peekOfCode": "\t\t\t\tind = i\n\t\t\ti += 1\n\t\t# Return position of the element\n\t\treturn ind\n\t# Function to remove the element with\n\t# the highest priority\n\t@staticmethod\n\tdef dequeue() :\n\t\t# Find the position of the element\n\t\t# with highest priority",
        "detail": "Operating_System_Algorithms.priority_Queue",
        "documentation": {}
    },
    {
        "label": "\t\tind",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.priority_Queue",
        "description": "Operating_System_Algorithms.priority_Queue",
        "peekOfCode": "\t\tind = GFG.peek()\n\t\t# Shift the element one index before\n\t\t# from the position of the element\n\t\t# with highest priority is found\n\t\ti = ind\n\t\twhile (i < GFG.size) :\n\t\t\tGFG.pr[i] = GFG.pr[i + 1]\n\t\t\ti += 1\n\t\t# Decrease the size of the\n\t\t# priority queue by one",
        "detail": "Operating_System_Algorithms.priority_Queue",
        "documentation": {}
    },
    {
        "label": "\t\ti",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.priority_Queue",
        "description": "Operating_System_Algorithms.priority_Queue",
        "peekOfCode": "\t\ti = ind\n\t\twhile (i < GFG.size) :\n\t\t\tGFG.pr[i] = GFG.pr[i + 1]\n\t\t\ti += 1\n\t\t# Decrease the size of the\n\t\t# priority queue by one\n\t\tGFG.size -= 1\n\t@staticmethod\n\tdef main( args) :\n\t\t# Function Call to insert elements",
        "detail": "Operating_System_Algorithms.priority_Queue",
        "documentation": {}
    },
    {
        "label": "\t\t\tGFG.pr[i]",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.priority_Queue",
        "description": "Operating_System_Algorithms.priority_Queue",
        "peekOfCode": "\t\t\tGFG.pr[i] = GFG.pr[i + 1]\n\t\t\ti += 1\n\t\t# Decrease the size of the\n\t\t# priority queue by one\n\t\tGFG.size -= 1\n\t@staticmethod\n\tdef main( args) :\n\t\t# Function Call to insert elements\n\t\t# as per the priority\n\t\tGFG.enqueue(10, 2)",
        "detail": "Operating_System_Algorithms.priority_Queue",
        "documentation": {}
    },
    {
        "label": "\t\tind",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.priority_Queue",
        "description": "Operating_System_Algorithms.priority_Queue",
        "peekOfCode": "\t\tind = GFG.peek()\n\t\tprint(GFG.pr[ind].value)\n\t\t# Dequeue the top element\n\t\tGFG.dequeue()\n\t\t# Check the top element\n\t\tind = GFG.peek()\n\t\tprint(GFG.pr[ind].value)\n\t\t# Dequeue the top element\n\t\tGFG.dequeue()\n\t\t# Check the top element",
        "detail": "Operating_System_Algorithms.priority_Queue",
        "documentation": {}
    },
    {
        "label": "\t\tind",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.priority_Queue",
        "description": "Operating_System_Algorithms.priority_Queue",
        "peekOfCode": "\t\tind = GFG.peek()\n\t\tprint(GFG.pr[ind].value)\n\t\t# Dequeue the top element\n\t\tGFG.dequeue()\n\t\t# Check the top element\n\t\tind = GFG.peek()\n\t\tprint(GFG.pr[ind].value)\nif __name__==\"__main__\":\n\tGFG.main([])\n# ---------------------------------------------------------------------------------------",
        "detail": "Operating_System_Algorithms.priority_Queue",
        "documentation": {}
    },
    {
        "label": "\t\tind",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.priority_Queue",
        "description": "Operating_System_Algorithms.priority_Queue",
        "peekOfCode": "\t\tind = GFG.peek()\n\t\tprint(GFG.pr[ind].value)\nif __name__==\"__main__\":\n\tGFG.main([])\n# ---------------------------------------------------------------------------------------\n# Implement Priority Queue Using Linked List:  friday , saturday , sunday !!\n# ---------------------------------------------------------------------------------------\n#     \tjava    os    maths    dsa",
        "detail": "Operating_System_Algorithms.priority_Queue",
        "documentation": {}
    },
    {
        "label": "ProducerConsumer",
        "kind": 6,
        "importPath": "Operating_System_Algorithms.producer_consumer_problem",
        "description": "Operating_System_Algorithms.producer_consumer_problem",
        "peekOfCode": "class ProducerConsumer:\n    def __init__(self, buffer_size=10):\n        self.buffer = [None] * buffer_size\n        self.buffer_size = buffer_size\n        self.in_index = 0\n        self.out_index = 0\n    def produce(self, item):\n        if (self.in_index + 1) % self.buffer_size == self.out_index:\n            print(\"Buffer is Full\")\n        else:",
        "detail": "Operating_System_Algorithms.producer_consumer_problem",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Operating_System_Algorithms.producer_consumer_problem",
        "description": "Operating_System_Algorithms.producer_consumer_problem",
        "peekOfCode": "def main():\n    pc = ProducerConsumer(buffer_size=10)\n    choice = 0\n    while choice != 3:\n        print(\"\\n1. Produce \\t 2. Consume \\t 3. Exit\")\n        choice = int(input(\"Enter your choice: \"))\n        if choice == 1:\n            item = int(input(\"Enter the value: \"))\n            pc.produce(item)\n        elif choice == 2:",
        "detail": "Operating_System_Algorithms.producer_consumer_problem",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Operating_System_Algorithms.Resource_Allocation_Graph_(RAG)_algorithm",
        "description": "Operating_System_Algorithms.Resource_Allocation_Graph_(RAG)_algorithm",
        "peekOfCode": "def main(): #ðŸ˜‚ðŸ˜‚ðŸ˜‚ðŸ˜‚\n    np = int(input(\"Enter the number of processes: \"))\n    nr = int(input(\"Enter the number of resources: \"))\n    r = [int(input(f\"Total amount of resource R{i + 1}: \")) for i in range(nr)]\n    print(\"\\nEnter the request matrix:\")\n    request = [[int(input()) for _ in range(nr)] for _ in range(np)]\n    print(\"\\nEnter the allocation matrix:\")\n    alloc = [[int(input()) for _ in range(nr)] for _ in range(np)]\n    # Available resource calculation\n    avail = [r[j] - sum(alloc[i][j] for i in range(np)) for j in range(nr)]",
        "detail": "Operating_System_Algorithms.Resource_Allocation_Graph_(RAG)_algorithm",
        "documentation": {}
    },
    {
        "label": "round_robin",
        "kind": 2,
        "importPath": "Operating_System_Algorithms.Round_Robin_algo",
        "description": "Operating_System_Algorithms.Round_Robin_algo",
        "peekOfCode": "def round_robin(processes, burst_times, time_slice):\n    n = len(processes) \n    remaining_burst_times = burst_times[:]  # Copy of burst times\n    waiting_times = [0] * n\n    turnaround_times = [0] * n\n    total_waiting_time = 0\n    total_turnaround_time = 0\n    current_time = 0  \n    while True:\n        done = True",
        "detail": "Operating_System_Algorithms.Round_Robin_algo",
        "documentation": {}
    },
    {
        "label": "processes",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.Round_Robin_algo",
        "description": "Operating_System_Algorithms.Round_Robin_algo",
        "peekOfCode": "processes = [1, 2, 3, 4]\nburst_times = [5, 4, 3, 2]\ntime_slice = 2\nround_robin(processes, burst_times, time_slice)",
        "detail": "Operating_System_Algorithms.Round_Robin_algo",
        "documentation": {}
    },
    {
        "label": "burst_times",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.Round_Robin_algo",
        "description": "Operating_System_Algorithms.Round_Robin_algo",
        "peekOfCode": "burst_times = [5, 4, 3, 2]\ntime_slice = 2\nround_robin(processes, burst_times, time_slice)",
        "detail": "Operating_System_Algorithms.Round_Robin_algo",
        "documentation": {}
    },
    {
        "label": "time_slice",
        "kind": 5,
        "importPath": "Operating_System_Algorithms.Round_Robin_algo",
        "description": "Operating_System_Algorithms.Round_Robin_algo",
        "peekOfCode": "time_slice = 2\nround_robin(processes, burst_times, time_slice)",
        "detail": "Operating_System_Algorithms.Round_Robin_algo",
        "documentation": {}
    },
    {
        "label": "SJF_Scheduling",
        "kind": 2,
        "importPath": "Operating_System_Algorithms.Shortest_Job_First (SJF)_Algo",
        "description": "Operating_System_Algorithms.Shortest_Job_First (SJF)_Algo",
        "peekOfCode": "def SJF_Scheduling(processes):\n    n = len(processes)\n    total_waiting_time = 0\n    total_turnaround_time = 0\n    # Sort processes based on burst time (shortest job first)\n    processes.sort(key=lambda x: x[1])\n    waiting_time = [0] * n\n    turnaround_time = [0] * n\n    # First process has 0 waiting time\n    waiting_time[0] = 0",
        "detail": "Operating_System_Algorithms.Shortest_Job_First (SJF)_Algo",
        "documentation": {}
    },
    {
        "label": "reverse_words_in_string",
        "kind": 2,
        "importPath": "Questions.revers_word_without_word",
        "description": "Questions.revers_word_without_word",
        "peekOfCode": "def reverse_words_in_string(S):\n    words = S.split('.')\n    words.reverse()    \n    reversed_string = '.'.join(words)\n    return reversed_string",
        "detail": "Questions.revers_word_without_word",
        "documentation": {}
    },
    {
        "label": "Deque",
        "kind": 6,
        "importPath": "Queue.DEQUEUE",
        "description": "Queue.DEQUEUE",
        "peekOfCode": "class Deque:\n    def __init__(self):\n        self.items = []\n    def is_empty(self):\n        return len(self.items) == 0\n    def add_front(self, item):\n        self.items.insert(0, item)\n        print(item, \"added to the front of deque\")\n    def add_rear(self, item):\n        self.items.append(item)",
        "detail": "Queue.DEQUEUE",
        "documentation": {}
    },
    {
        "label": "menu",
        "kind": 2,
        "importPath": "Queue.DEQUEUE",
        "description": "Queue.DEQUEUE",
        "peekOfCode": "def menu():\n    deque = Deque()\n    while True:\n        print(\"\\n0. Create a Deque with n elements \")\n        print(\"1. Add to front\")\n        print(\"2. Add to rear\")\n        print(\"3. Remove from front\")\n        print(\"4. Remove from rear\")\n        print(\"5. Display Deque\")\n        print(\"6. Exit\\n\")",
        "detail": "Queue.DEQUEUE",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "Queue.DEQUEUE_Linked_List",
        "description": "Queue.DEQUEUE_Linked_List",
        "peekOfCode": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n        self.prev = None\nclass Deque:\n    def __init__(self):\n        self.front = None\n        self.rear = None\n    def is_empty(self):",
        "detail": "Queue.DEQUEUE_Linked_List",
        "documentation": {}
    },
    {
        "label": "Deque",
        "kind": 6,
        "importPath": "Queue.DEQUEUE_Linked_List",
        "description": "Queue.DEQUEUE_Linked_List",
        "peekOfCode": "class Deque:\n    def __init__(self):\n        self.front = None\n        self.rear = None\n    def is_empty(self):\n        return self.front is None\n    def add_front(self, item):\n        new_node = Node(item)\n        if self.is_empty():\n            self.front = self.rear = new_node",
        "detail": "Queue.DEQUEUE_Linked_List",
        "documentation": {}
    },
    {
        "label": "menu",
        "kind": 2,
        "importPath": "Queue.DEQUEUE_Linked_List",
        "description": "Queue.DEQUEUE_Linked_List",
        "peekOfCode": "def menu():\n    deque = Deque()\n    while True:\n        print(\"\\n0. Create a Deque with n elements \")\n        print(\"1. Add to front\")\n        print(\"2. Add to rear\")\n        print(\"3. Remove from front\")\n        print(\"4. Remove from rear\")\n        print(\"5. Display Deque\")\n        print(\"6. Exit\\n\")",
        "detail": "Queue.DEQUEUE_Linked_List",
        "documentation": {}
    },
    {
        "label": "Queue",
        "kind": 6,
        "importPath": "Queue.queue",
        "description": "Queue.queue",
        "peekOfCode": "class Queue:\n    def __init__(self):\n        self.queue = []\n    def isEmpty(self):\n        return len(self.queue) == 0\n    def enqueue(self, data):\n        self.queue.append(data)\n        print(data, \"added to queue\")\n    def dequeue(self):\n        if not self.isEmpty():",
        "detail": "Queue.queue",
        "documentation": {}
    },
    {
        "label": "menu",
        "kind": 2,
        "importPath": "Queue.queue",
        "description": "Queue.queue",
        "peekOfCode": "def menu():\n    queue = Queue()\n    while True:\n        print(\"\\n0. Create a Queue of n elements \")\n        print(\"1. Enqueue\")\n        print(\"2. Dequeue\")\n        print(\"3. Display Queue\")\n        print(\"4. Exit\\n\")\n        ch = input(\"Enter your choice: \")\n        while ch not in ('0', '1', '2', '3', '4'):",
        "detail": "Queue.queue",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "Queue.queue_Linked_List",
        "description": "Queue.queue_Linked_List",
        "peekOfCode": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\nclass Queue:\n    def __init__(self):\n        self.front = None\n        self.rear = None\n    def isEmpty(self):\n        return self.front is None",
        "detail": "Queue.queue_Linked_List",
        "documentation": {}
    },
    {
        "label": "Queue",
        "kind": 6,
        "importPath": "Queue.queue_Linked_List",
        "description": "Queue.queue_Linked_List",
        "peekOfCode": "class Queue:\n    def __init__(self):\n        self.front = None\n        self.rear = None\n    def isEmpty(self):\n        return self.front is None\n    def display(self):\n        if self.isEmpty():\n            print(\"Queue is Empty ! \\nNothing to display\")\n        else:",
        "detail": "Queue.queue_Linked_List",
        "documentation": {}
    },
    {
        "label": "menu",
        "kind": 2,
        "importPath": "Queue.queue_Linked_List",
        "description": "Queue.queue_Linked_List",
        "peekOfCode": "def menu():\n    queue = Queue()\n    while True:\n        print(\"\\n0. Create a Queue of n elements \")\n        print(\"1. Enqueue\")\n        print(\"2. Dequeue\")\n        print(\"3. Display Queue\")\n        print(\"4. Exit\\n\")\n        ch = input(\"Enter your choice: \")\n        while ch not in ('0', '1', '2', '3', '4'):",
        "detail": "Queue.queue_Linked_List",
        "documentation": {}
    },
    {
        "label": "fact_recursive",
        "kind": 2,
        "importPath": "Recursion.factorial",
        "description": "Recursion.factorial",
        "peekOfCode": "def fact_recursive(n):\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return n * fact_recursive(n - 1)\ndef fact_iterative(n):\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result",
        "detail": "Recursion.factorial",
        "documentation": {}
    },
    {
        "label": "fact_iterative",
        "kind": 2,
        "importPath": "Recursion.factorial",
        "description": "Recursion.factorial",
        "peekOfCode": "def fact_iterative(n):\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result\ndef main():\n    while True:\n        print(\"\\nMenu:\")\n        print(\"1. Calculate Factorial (Recursive)\")\n        print(\"2. Calculate Factorial (Iterative)\")",
        "detail": "Recursion.factorial",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Recursion.factorial",
        "description": "Recursion.factorial",
        "peekOfCode": "def main():\n    while True:\n        print(\"\\nMenu:\")\n        print(\"1. Calculate Factorial (Recursive)\")\n        print(\"2. Calculate Factorial (Iterative)\")\n        print(\"3. Exit\")\n        choice = input(\"Enter your choice: \")\n        while choice not in ('1', '2', '3'):\n            print(\"Invalid choice. Please try again.\")\n            choice = input(\"Enter your choice: \")",
        "detail": "Recursion.factorial",
        "documentation": {}
    },
    {
        "label": "fibo_recursive",
        "kind": 2,
        "importPath": "Recursion.Fibonacci_series",
        "description": "Recursion.Fibonacci_series",
        "peekOfCode": "def fibo_recursive(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fibo_recursive(n - 1) + fibo_recursive(n - 2)\ndef fibo_iterative(n):\n    if n == 0:\n        return 0",
        "detail": "Recursion.Fibonacci_series",
        "documentation": {}
    },
    {
        "label": "fibo_iterative",
        "kind": 2,
        "importPath": "Recursion.Fibonacci_series",
        "description": "Recursion.Fibonacci_series",
        "peekOfCode": "def fibo_iterative(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\ndef print_fibonacci_series(n, method):",
        "detail": "Recursion.Fibonacci_series",
        "documentation": {}
    },
    {
        "label": "print_fibonacci_series",
        "kind": 2,
        "importPath": "Recursion.Fibonacci_series",
        "description": "Recursion.Fibonacci_series",
        "peekOfCode": "def print_fibonacci_series(n, method):\n    print(\"Fibonacci series up to\", n, \"terms:\")\n    for i in range(n):\n        if method == 'recursive':\n            print(fibo_recursive(i))\n        else:\n            print(fibo_iterative(i))\ndef get_fibonacci_term(n, method):\n    if method == 'recursive':\n        return fibo_recursive(n)",
        "detail": "Recursion.Fibonacci_series",
        "documentation": {}
    },
    {
        "label": "get_fibonacci_term",
        "kind": 2,
        "importPath": "Recursion.Fibonacci_series",
        "description": "Recursion.Fibonacci_series",
        "peekOfCode": "def get_fibonacci_term(n, method):\n    if method == 'recursive':\n        return fibo_recursive(n)\n    else:\n        return fibo_iterative(n)\ndef main():\n    while True:\n        print(\"\\nMenu:\")\n        print(\"1. Print Fibonacci series up to n terms\")\n        print(\"2. Get the nth term of the Fibonacci series\")",
        "detail": "Recursion.Fibonacci_series",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Recursion.Fibonacci_series",
        "description": "Recursion.Fibonacci_series",
        "peekOfCode": "def main():\n    while True:\n        print(\"\\nMenu:\")\n        print(\"1. Print Fibonacci series up to n terms\")\n        print(\"2. Get the nth term of the Fibonacci series\")\n        print(\"3. Exit\")\n        choice = input(\"Enter your choice: \")\n        while choice not in ('1', '2', '3'):\n            print(\"Invalid choice. Please try again.\")\n            choice = input(\"Enter your choice: \")",
        "detail": "Recursion.Fibonacci_series",
        "documentation": {}
    },
    {
        "label": "HCF",
        "kind": 2,
        "importPath": "Recursion.GCD_and_LCM",
        "description": "Recursion.GCD_and_LCM",
        "peekOfCode": "def HCF(a, b):\n    if (b == 0):\n        return abs(a)\n    else:\n        return HCF(b, a % b)\n    # while b != 0:\n    # a, b = b, a % b\n    # return a\ndef lcm(a, b):\n    if a == 0 or b == 0:",
        "detail": "Recursion.GCD_and_LCM",
        "documentation": {}
    },
    {
        "label": "lcm",
        "kind": 2,
        "importPath": "Recursion.GCD_and_LCM",
        "description": "Recursion.GCD_and_LCM",
        "peekOfCode": "def lcm(a, b):\n    if a == 0 or b == 0:\n        return 0\n    else:\n        return abs(a * b) // HCF(a, b)\n        # return (a // HCF(a,b))* b\ndef main():\n    while True:\n        print(\"\\nMenu:\")\n        print(\"1. Calculate GCD\")",
        "detail": "Recursion.GCD_and_LCM",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Recursion.GCD_and_LCM",
        "description": "Recursion.GCD_and_LCM",
        "peekOfCode": "def main():\n    while True:\n        print(\"\\nMenu:\")\n        print(\"1. Calculate GCD\")\n        print(\"2. Calculate LCM\")\n        print(\"3. Exit\")\n        choice = input(\"Enter your choice: \")\n        while choice not in ('1', '2', '3'):\n            print(\"Invalid choice. Please try again.\")\n            choice = input(\"Enter your choice: \")",
        "detail": "Recursion.GCD_and_LCM",
        "documentation": {}
    },
    {
        "label": "tower_of_hanoi",
        "kind": 2,
        "importPath": "Recursion.Tower_of_Hanoi",
        "description": "Recursion.Tower_of_Hanoi",
        "peekOfCode": "def tower_of_hanoi(n, source, auxiliary, target):\n    # if n == 1:\n        # print(f\"Move disk 1 from {source} to {target}\")\n    if n == 0:\n        return\n    tower_of_hanoi(n - 1, source, target, auxiliary)\n    print(f\"Move disk {n} from {source} to {target}\")\n    tower_of_hanoi(n - 1, auxiliary, source, target)\ndef main():\n    while True:",
        "detail": "Recursion.Tower_of_Hanoi",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Recursion.Tower_of_Hanoi",
        "description": "Recursion.Tower_of_Hanoi",
        "peekOfCode": "def main():\n    while True:\n        print(\"\\nMenu:\")\n        print(\"1. Solve Tower of Hanoi\")\n        print(\"2. Display minimum number of steps\")\n        print(\"3. Exit\")\n        choice = input(\"Enter your choice: \")\n        while choice not in ('1', '2', '3'):\n            print(\"Invalid choice. Please try again.\")\n            choice = input(\"Enter your choice: \")",
        "detail": "Recursion.Tower_of_Hanoi",
        "documentation": {}
    },
    {
        "label": "bubbleSort",
        "kind": 2,
        "importPath": "Sorting_Algorithms.Bubble_Sort",
        "description": "Sorting_Algorithms.Bubble_Sort",
        "peekOfCode": "def bubbleSort(arr):\n    n = len(arr)\n    # Traverse through all array elements\n    for i in range(n):\n        swapped = False\n        # Last i elements are already in place\n        for j in range(0, n-i-1):\n            # Swap if the element found > next element\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]",
        "detail": "Sorting_Algorithms.Bubble_Sort",
        "documentation": {}
    },
    {
        "label": "heapify",
        "kind": 2,
        "importPath": "Sorting_Algorithms.Heap_Sort",
        "description": "Sorting_Algorithms.Heap_Sort",
        "peekOfCode": "def heapify(arr, N, i):\n    largest = i  # Initialize largest as root\n    l = 2 * i + 1\n    r = 2 * i + 2\n    if l < N and arr[largest] < arr[l]:\n        largest = l\n    if r < N and arr[largest] < arr[r]:\n        largest = r\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]",
        "detail": "Sorting_Algorithms.Heap_Sort",
        "documentation": {}
    },
    {
        "label": "heapSort",
        "kind": 2,
        "importPath": "Sorting_Algorithms.Heap_Sort",
        "description": "Sorting_Algorithms.Heap_Sort",
        "peekOfCode": "def heapSort(arr):\n    N = len(arr)\n    # Build a maxheap.\n    for i in range(N//2 - 1, -1, -1):\n        heapify(arr, N, i)\n    for i in range(N-1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapify(arr, i, 0)\narr = [12, 11, 13, 5, 6, 7]\nheapSort(arr)",
        "detail": "Sorting_Algorithms.Heap_Sort",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "Sorting_Algorithms.Heap_Sort",
        "description": "Sorting_Algorithms.Heap_Sort",
        "peekOfCode": "arr = [12, 11, 13, 5, 6, 7]\nheapSort(arr)\nN = len(arr)\nprint(\"Sorted array : \", arr)",
        "detail": "Sorting_Algorithms.Heap_Sort",
        "documentation": {}
    },
    {
        "label": "N",
        "kind": 5,
        "importPath": "Sorting_Algorithms.Heap_Sort",
        "description": "Sorting_Algorithms.Heap_Sort",
        "peekOfCode": "N = len(arr)\nprint(\"Sorted array : \", arr)",
        "detail": "Sorting_Algorithms.Heap_Sort",
        "documentation": {}
    },
    {
        "label": "insertionSort",
        "kind": 2,
        "importPath": "Sorting_Algorithms.Insertion_Sort",
        "description": "Sorting_Algorithms.Insertion_Sort",
        "peekOfCode": "def insertionSort(arr):\n    # Traverse through 1 to len(arr)\n    for i in range(1, len(arr)):\n        key = arr[i]\n        # Move elements of arr[0..i-1], that are\n        # greater than key, to one position ahead\n        # of their current position\n        j = i-1\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]",
        "detail": "Sorting_Algorithms.Insertion_Sort",
        "documentation": {}
    },
    {
        "label": "merge",
        "kind": 2,
        "importPath": "Sorting_Algorithms.Merge_Sort",
        "description": "Sorting_Algorithms.Merge_Sort",
        "peekOfCode": "def merge(array, left, mid, right):\n    subArrayOne = mid - left + 1\n    subArrayTwo = right - mid\n    # Create temp arrays\n    leftArray = [0] * subArrayOne\n    rightArray = [0] * subArrayTwo\n    # Copy data to temp arrays leftArray[] and rightArray[]\n    for i in range(subArrayOne):\n        leftArray[i] = array[left + i]\n    for j in range(subArrayTwo):",
        "detail": "Sorting_Algorithms.Merge_Sort",
        "documentation": {}
    },
    {
        "label": "mergeSort",
        "kind": 2,
        "importPath": "Sorting_Algorithms.Merge_Sort",
        "description": "Sorting_Algorithms.Merge_Sort",
        "peekOfCode": "def mergeSort(array, begin, end):\n    if begin >= end:\n        return\n    mid = begin + (end - begin) // 2\n    mergeSort(array, begin, mid)\n    mergeSort(array, mid + 1, end)\n    merge(array, begin, mid, end)\narr = [12, 11, 13, 5, 6, 7]\narr_size = len(arr)\nprint(\"Input Array is : \", arr)",
        "detail": "Sorting_Algorithms.Merge_Sort",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "Sorting_Algorithms.Merge_Sort",
        "description": "Sorting_Algorithms.Merge_Sort",
        "peekOfCode": "arr = [12, 11, 13, 5, 6, 7]\narr_size = len(arr)\nprint(\"Input Array is : \", arr)\nmergeSort(arr, 0, arr_size - 1)\nprint(\"\\nSorted array is : \", arr)",
        "detail": "Sorting_Algorithms.Merge_Sort",
        "documentation": {}
    },
    {
        "label": "arr_size",
        "kind": 5,
        "importPath": "Sorting_Algorithms.Merge_Sort",
        "description": "Sorting_Algorithms.Merge_Sort",
        "peekOfCode": "arr_size = len(arr)\nprint(\"Input Array is : \", arr)\nmergeSort(arr, 0, arr_size - 1)\nprint(\"\\nSorted array is : \", arr)",
        "detail": "Sorting_Algorithms.Merge_Sort",
        "documentation": {}
    },
    {
        "label": "partition",
        "kind": 2,
        "importPath": "Sorting_Algorithms.Quick_Sort",
        "description": "Sorting_Algorithms.Quick_Sort",
        "peekOfCode": "def partition(array, low, high):\n    '''Function to find the partition position'''\n    # Choose the rightmost element as pivot\n    pivot = array[high]\n    # Pointer for greater element\n    i = low - 1\n    # Traverse through all elements\n    # compare each element with pivot\n    for j in range(low, high):\n        if array[j] <= pivot:",
        "detail": "Sorting_Algorithms.Quick_Sort",
        "documentation": {}
    },
    {
        "label": "quicksort",
        "kind": 2,
        "importPath": "Sorting_Algorithms.Quick_Sort",
        "description": "Sorting_Algorithms.Quick_Sort",
        "peekOfCode": "def quicksort(array, low, high):\n    if low < high:\n        # Find pivot element such that\n        # element smaller than pivot are on the left\n        # element greater than pivot are on the right\n        pi = partition(array, low, high)\n        # Recursive call on the left of pivot\n        quicksort(array, low, pi - 1)\n        # Recursive call on the right of pivot\n        quicksort(array, pi + 1, high)",
        "detail": "Sorting_Algorithms.Quick_Sort",
        "documentation": {}
    },
    {
        "label": "array",
        "kind": 5,
        "importPath": "Sorting_Algorithms.Quick_Sort",
        "description": "Sorting_Algorithms.Quick_Sort",
        "peekOfCode": "array = [10, 7, 8, 9, 1, 5]\nN = len(array)\nquicksort(array, 0, N - 1)\nprint('Sorted array:',array)",
        "detail": "Sorting_Algorithms.Quick_Sort",
        "documentation": {}
    },
    {
        "label": "N",
        "kind": 5,
        "importPath": "Sorting_Algorithms.Quick_Sort",
        "description": "Sorting_Algorithms.Quick_Sort",
        "peekOfCode": "N = len(array)\nquicksort(array, 0, N - 1)\nprint('Sorted array:',array)",
        "detail": "Sorting_Algorithms.Quick_Sort",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "Sorting_Algorithms.selection_sort",
        "description": "Sorting_Algorithms.selection_sort",
        "peekOfCode": "arr = [64, 25, 12, 22, 11]\n# Traverse through all array elements\nfor i in range(len(arr)-1):    \n    min_idx = i\n    for j in range(i+1, len(arr)):\n        if arr[min_idx] > arr[j]:\n            min_idx = j\n    # Swap the found minimum element with the \"first\" element        \n    arr[i], arr[min_idx] = arr[min_idx], arr[i]\nprint(\"This is your Sorted array : \",arr)",
        "detail": "Sorting_Algorithms.selection_sort",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": "Stack.stack",
        "description": "Stack.stack",
        "peekOfCode": "class Stack:\n    def __init__(self):\n        self.stack = []\n    def isEmpty(self):\n        # return self.stack == []\n        return len(self.stack) == 0\n    def pushStack(self, data):\n        self.stack.append(data)\n        print(f\"Pushed {data} onto the stack.\")\n    def popStack(self):",
        "detail": "Stack.stack",
        "documentation": {}
    },
    {
        "label": "menu",
        "kind": 2,
        "importPath": "Stack.stack",
        "description": "Stack.stack",
        "peekOfCode": "def menu():\n    stack = Stack()\n    while True:\n        print(\"\\n0. Create a Stack of n elements \")\n        print(\"1. Push\")\n        print(\"2. Pop\")\n        print(\"3. Peek\")\n        print(\"4. Display Stack\")\n        print(\"5. Exit\\n\")\n        ch = input(\"Enter your choice: \")",
        "detail": "Stack.stack",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "Stack.stack_Linked_List",
        "description": "Stack.stack_Linked_List",
        "peekOfCode": "class Node:\n    def __init__(self,data):\n        self.data = data\n        self.next = None\nclass Stack:\n    def __init__(self):\n        self.head = None\n        self.length = 0\n    def isEmpty(self):\n        return self.head is None",
        "detail": "Stack.stack_Linked_List",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": "Stack.stack_Linked_List",
        "description": "Stack.stack_Linked_List",
        "peekOfCode": "class Stack:\n    def __init__(self):\n        self.head = None\n        self.length = 0\n    def isEmpty(self):\n        return self.head is None\n    def display(self):\n        if self.head:\n            print(\"This is your Stack:\")\n            current = self.head",
        "detail": "Stack.stack_Linked_List",
        "documentation": {}
    },
    {
        "label": "menu",
        "kind": 2,
        "importPath": "Stack.stack_Linked_List",
        "description": "Stack.stack_Linked_List",
        "peekOfCode": "def menu():\n    stack = Stack()\n    while True:\n        print(\"\\nMenu:\")\n        print(\"0. Create a Stack of n Nodes\")\n        print(\"1. Push\")\n        print(\"2. Pop\")\n        print(\"3. Peek\")\n        print(\"4. Display\")\n        print(\"5. Exit\")",
        "detail": "Stack.stack_Linked_List",
        "documentation": {}
    }
]